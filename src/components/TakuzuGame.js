import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom'; // Pour la redirection
import { Container, Row, Col, Button, Modal, Form } from 'react-bootstrap';
import { getFirestore, collection, addDoc, serverTimestamp } from "firebase/firestore";
import app from './firebase'; // Assurez-vous de corriger le chemin du fichier si nécessaire

import takuzuData from '../data/takuzuData.json';

const TakuzuGame = ({ isLoggedIn }) => { // Ajout du prop isLoggedIn
  const [board, setBoard] = useState([]);
  const [winner, setWinner] = useState(false);
  const [showModal, setShowModal] = useState(false);
  const [elapsedTime, setElapsedTime] = useState(0); // État pour suivre le temps écoulé
  const [timerStarted, setTimerStarted] = useState(false); // État pour suivre si le chronomètre a démarré
  const [pseudo, setPseudo] = useState('');
  const [formValid, setFormValid] = useState(false);
  const navigate = useNavigate();

  useEffect(() => {
    importTakuzu();
  }, []);

  const importTakuzu = () => {
    const initialBoard = takuzuData.takuzu[0];
    const newBoard = Object.values(initialBoard).map(row => row.split('').map(cell => ({ value: cell === '-' ? null : parseInt(cell), isAutoGenerated: cell !== '-' })));
    setBoard(newBoard);
  };

  const handleCellClick = (rowIndex, colIndex) => {
    if (!winner) {
      if (!timerStarted) { // Démarrer le chronomètre lors de la première action sur la grille
        startTimer();
      }
      const newBoard = [...board];
      const cell = newBoard[rowIndex][colIndex];
      if (!cell.isAutoGenerated) {
        const newValue = cell.value === null ? 0 : cell.value === 0 ? 1 : null;
        newBoard[rowIndex][colIndex] = { value: newValue, isAutoGenerated: false, isManual: true };
        setBoard(newBoard);
        if (checkWinner(newBoard)) {
          setWinner(true);
          setShowModal(true);
          stopTimer(); // Arrêter le chronomètre lorsque le joueur gagne
        }
      }
    }
  };

  const checkConsecutiveSymbols = (array) => {
    for (let i = 0; i < array.length - 2; i++) {
      if (array[i] !== null && array[i] === array[i + 1] && array[i] === array[i + 2]) {
        return true; // Renvoie vrai s'il y a trois symboles consécutifs identiques
      }
    }
    return false; // Renvoie faux sinon
  };

  const checkEqualNumberOfSymbols = (array) => {
    const zeros = array.filter(value => value === 0).length;
    const ones = array.filter(value => value === 1).length;
    return zeros === ones; // Renvoie vrai si le nombre de 0 et de 1 est égal
  };

  const checkUniqueRowsAndColumns = (board) => {
    const rows = board.map(row => row.map(cell => cell.value).join(''));
    const columns = board[0].map((_, colIndex) => board.map(row => row[colIndex].value).join(''));
    const uniqueRows = new Set(rows);
    const uniqueColumns = new Set(columns);
    return uniqueRows.size === rows.length && uniqueColumns.size === columns.length; // Renvoie vrai si toutes les lignes et colonnes sont uniques
  };

  const checkWinner = (currentBoard) => {
    const flatBoard = currentBoard.flat();
    const isBoardFull = flatBoard.every(cell => cell.value !== null);
    if (isBoardFull) {
      // Vérifier les lignes
      for (let i = 0; i < currentBoard.length; i++) {
        if (checkConsecutiveSymbols(currentBoard[i]) || !checkEqualNumberOfSymbols(currentBoard[i])) {
          return false; // Si une ligne contient trois symboles consécutifs identiques ou un nombre inégal de 0 et de 1, le joueur a perdu
        }
      }
      // Vérifier les colonnes
      for (let i = 0; i < currentBoard.length; i++) {
        const column = currentBoard.map(row => row[i]);
        if (checkConsecutiveSymbols(column) || !checkEqualNumberOfSymbols(column)) {
          return false; // Si une colonne contient trois symboles consécutifs identiques ou un nombre inégal de 0 et de 1, le joueur a perdu
        }
      }
      // Vérifier l'unicité des lignes et colonnes
      if (!checkUniqueRowsAndColumns(currentBoard)) {
        return false; // Si les lignes ou les colonnes ne sont pas uniques, le joueur a perdu
      }
      return true; // Si toutes les conditions sont remplies, le joueur a gagné
    }
    return false; // Si le tableau n'est pas plein, le jeu continue
  };

  const handleReset = () => {
    importTakuzu();
    setWinner(false);
    setElapsedTime(0); // Réinitialiser le temps écoulé lorsque le Takuzu est réinitialisé
    setTimerStarted(false); // Réinitialiser le statut du chronomètre
  };

  const handleCloseModal = () => {
    setShowModal(false);
    if (!isLoggedIn) {
      navigate('/scoreboard'); // Rediriger vers la page de classement
    }
  };

  const handlePseudoChange = (e) => {
    const value = e.target.value;
    setPseudo(value);
    setFormValid(!!value); // Mettre à jour l'état formValid en fonction de la valeur du pseudo
  };

  const handleSubmit = () => {
    saveWinnerTime(elapsedTime).then(() => {
      navigate('/scoreboard'); // Rediriger vers la page de classement
    });
  };

  const startTimer = () => {
    setTimerStarted(true); // Marquer le démarrage du chronomètre
    const timer = setInterval(() => {
      setElapsedTime(prevElapsedTime => prevElapsedTime + 1); // Incrémenter le temps écoulé chaque seconde
    }, 1000);
    return () => clearInterval(timer); // Retourner une fonction de nettoyage pour effacer l'intervalle lors du démontage du composant
  };

  const stopTimer = () => {
    setTimerStarted(false); // Réinitialiser le statut du chronomètre
  };

  const saveWinnerTime = async (time) => {
    if (!pseudo) {
      console.error("Le champ de pseudo est obligatoire !");
      return;
    }
    const firestore = getFirestore(app);
    try {
      const docRef = await addDoc(collection(firestore, "winners"), {
        time: time,
        pseudo: pseudo,
        timestamp: serverTimestamp()
      });
      console.log("Winner time saved with ID: ", docRef.id);
    } catch (error) {
      console.error("Error adding winner time: ", error);
    }
  };

  return (
    <Container>
      <h1>Takuzu Du Jour</h1>
      <div>Temps écoulé: {elapsedTime} secondes</div>
      <Button onClick={handleReset}>Réinitialiser</Button>
      <Row>
        {board.map((row, rowIndex) => (
          <Row key={rowIndex}>
            {row.map((cell, colIndex) => (
              <Col key={colIndex} onClick={() => handleCellClick(rowIndex, colIndex)}>
                <div className={`cell ${cell.value === null ? 'empty' : cell.value === 0 ? 'cell-zero' : 'cell-one'} ${cell.isAutoGenerated ? 'cell-auto' : 'cell-manual'}`}>
                  {cell.value !== null && cell.value}
                </div>
              </Col>
            ))}
          </Row>
        ))}
      </Row>
      <Modal show={showModal} onHide={handleCloseModal}>
        <Modal.Header closeButton>
          <Modal.Title>Félicitations !</Modal.Title>
        </Modal.Header>
        <Modal.Body>
          {isLoggedIn ? (
            <>
              <p>Vous avez gagné en {elapsedTime} secondes !</p>
              <Form.Group className="mb-3" controlId="formBasicPseudo">
                <Form.Label>Pseudo</Form.Label>
                <Form.Control type="text" placeholder="Entrez votre pseudo" value={pseudo} onChange={handlePseudoChange} />
              </Form.Group>
            </>
          ) : (
            <p>Vous avez gagné en {elapsedTime} secondes !</p>
          )}
        </Modal.Body>
        <Modal.Footer>
          {isLoggedIn ? (
            <Button variant="primary" onClick={handleSubmit} disabled={!formValid}>
              Soumettre
            </Button>
          ) : (
            <Button variant="primary" onClick={() => navigate('/scoreboard')}>
              Voir le classement
            </Button>
          )}
        </Modal.Footer>
      </Modal>
    </Container>
  );
};

export default TakuzuGame;
